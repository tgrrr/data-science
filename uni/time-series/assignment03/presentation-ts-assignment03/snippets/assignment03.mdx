
```{r load-packages-and-scripts, message=FALSE, warning=FALSE}
library(packagr)
packages <- c(
  'AID', 'captioner', 'CombMSC', 'FitAR', 'fGarch', 'fGarch', 
  'forecast', 'FSAdata', 'fUnitRoots', 'ggplot2', 'gridExtra', 
  'lmtest', 'magrittr', 'nortest', 'purrr', 'readxl', 'rugarch', 
  'tidyr', 'tseries', 'TSA', 'tsibble', 'TTR', 'zoom' 
)
packagr(packages) 
# alpha package to check, install and load packages

# moved all functions to here
source('./utils.r') 
source('./MASE.r')
source('./TSHandy.r') 
```


```{r, env-variables}
startDate = '2013-04-27' #yyyy-mm-dd
endDate = '2019-02-24'
default_ylab = 'Bitcoin EOD closing price US$'
default_xlab = 'Year'
indsMASE <- seq(as.Date('2019-2-25'), as.Date('2019-3-6'), by = "day")
startForecast = c(2019, as.numeric(format(indsMASE[1], "%j")))
frequency = 365.25
```

```{r}
getwd()
# current_path = rstudioapi::getActiveDocumentContext()$path
# setwd(dirname(current_path ))
# print( getwd() )

data <-
  read.csv("./Bitcoin_Historical_Price.csv",
  sep = ",",
  fill = TRUE)
# data %>% class() # data.frame needs to be converted to time series

# Original code to load from xlsx:
real <- read_excel("Bitcoin_Prices_Forecasts.xlsx")
# saveTimeSeriesCSV(real)
# realCSV <- read.csv("./real.ts.csv", sep = ",", fill = TRUE) %>% ts()

```

```{r, data-wrangle}
# remove commas from currency - credit to Zoe
data$Close <- as.numeric(as.character(gsub(",","",data$Close)))
inds <- seq(as.Date(startDate), as.Date(endDate), by = "day")
data.ts <- ts(
  as.vector(data[,2]),
  start = c(2013, as.numeric(format(inds[1], "%j"))),
  frequency = frequency)
# Code source: https://stackoverflow.com/a/33129922

# data for calculating MASE
# Import the observed values for comparison with MASE

real.ts <- ts(
  real[,2],
  start = startForecast,
  frequency = frequency
)
```

```{r initial-data}
doPar(mfrow = c(1, 1))
plot(
  data.ts,
  type = 'l',
  main = fig_nums("bitcoin_ts_data", 
                  "Bitcoin time series data"),
  ylab = default_ylab)
```
 
```{r check-correlation}
y = data.ts        # Read data into y
x = zlag(data.ts)  # Generate first lag
index = 2:length(x) # get rid of the first NA value
cor(y[index], x[index])
doPar(mfrow = c(1, 1))
plot(
  y = data.ts,
  x = x,
  ylab = 'Closing Price',
  xlab = 'Previous Day Closing Price',
  main = fig_nums(
    "Scatter_neighbouring", 
    "Scatter plot of neighbouring Closing Prices")
)
```

```{r, linear-trend-model}
time = time(data.ts)
model_linear = lm(data.ts ~ time)
summary(model_linear)
```

```{r}
doPar(mfrow = c(1, 1))
plot(
  data.ts,
  main = fig_nums('linear_model_abline', 
    'Bitcoin Data with Linear Model'),
  ylab = default_ylab)
abline(model_linear)
```

```{r message=FALSE, warning=FALSE}
residual.analysis(
  model_linear, 
  std = TRUE, 
  start = 1,   
  title = fig_nums('linear_residual', 
    'Linear model residual analysis')
)

# fitted values
# add dates
forecastDatesRange <- data.frame(time = indsMASE)
# convert dates to numeric
numericDates <- ts(
  as.vector(forecastDatesRange),  
  start = startForecast, 
  frequency = frequency)
# ensure data has the same label (time)
time = time(numericDates)
timeDataFrame = data.frame(time)
# prediction
forecastLinear = predict.lm(
  model_linear, 
  timeDataFrame, 
  interval = "prediction")
print(forecastLinear)
# convert prediction back to ts object
linear_predict = ts(
  forecastLinear[,1],
  start = startForecast,
  frequency = frequency
)
```

```{r}              
# calculate MASE with observed and predicted values
MASE(real.ts, linear_predict)
# plot 
doPar(c(2,1))
plot(data.ts)
lines(real.ts, col = "red")
lines(linear_predict, col="red", type="l")
zoomplot.zoom(xlim=c(2019.1,2019.3))
```

```{r, quadratic-model}
time = time(data.ts)
time2 = time ^ 2
model_quadratic = lm(data.ts ~ time + time2) 
# label the quadratic trend model
summary(model_quadratic)
```

```{r}
doPar(mfrow = c(1, 1))
plot(
  ts(fitted(model_quadratic)),
  ylim = c(min(c(
    fitted(model_quadratic), as.vector(data.ts)
  )),
  max(c(
    fitted(model_quadratic), as.vector(data.ts)
  ))),
  ylab = default_ylab,
  main = fig_nums(
    "quadratic_model",
    "Bitcoin Data with Quadratic Model")
)
lines(as.vector(data.ts))
```

```{r}
newdata <- data.frame(time = indsMASE)
newdata1 <- ts(
  as.vector(newdata),
  start = startForecast, 
  frequency = frequency)

residual.analysis(
  model_quadratic, std = TRUE, start = 1,
  title = fig_nums(
    'quadratic_model_residual', 
    'Quadratic model residual analysis'))

# predict
time = time(newdata1)
time2 = time^2
newdata3 = data.frame(time,time2)
forecastQuadratic = predict(
  model_quadratic, 
  newdata3, 
  interval = "prediction")
print(forecastQuadratic)
quadratic_predict = ts(forecastQuadratic[,1], 
  start = startForecast,
  frequency = frequency)

MASE(real.ts, quadratic_predict)
```

```{r, plot-no-diff}
doDiffAndPlot(data.ts, 0, T, T, 'Bitcoin diff=0')
```

```{r, confidence-interval, warning=FALSE}
# check the confidence interval of lambda
# TODO: half-sized version of this plot
doPar(mfrow = c(1,1))
boxcoxCi <- BoxCox.ar(data.ts, method = "yule-walker")$ci
boxcoxCi
title(fig_nums('boxcox_ci',
  'Confidence Interval of Lambda of Bitcoin'), 
  line = -1.5, 
  outer = TRUE
)
```

```{r, log_transform}
data.ts__log = log(data.ts)
doDiffAndPlot(
  data.ts__log, 0, T, T,
  fig_nums("log_transform", "Log transform"))
```

```{r, log-first-diff}
doDiffAndPlot(
  data.ts__log, 1, T, T,
  fig_nums('log_first_diff', 'Log first diff'))
data.ts__log_diff1 = data.ts__log %>% diff(differences = 1)
```

- Based on EACF plot, we can add the following models:
`{ARIMA(0,1,1), ARIMA(1,1,1)}`

```{r, log-second-diff}
doDiffAndPlot(data.ts__log, 2, T, T,
  plotTitle = fig_nums('log_second_diff', 'Log second diff'))

data.ts__log_diff2 = data.ts__log %>% diff(differences = 2)
```
- Based on EACF plot, we can add the following models:
`{ARIMA(0,2,1), ARIMA(0,2,2), ARIMA(1,2,2)}`

### Get possible models formula

```{r}
findBestModel(data.ts__log)
```
