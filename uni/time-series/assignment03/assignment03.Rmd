---
title: "MATH1318 Time Series"
author: "Phil Steinke s3725547"
subtitle: Assignment 1 - Semester 1, 2019
output:
  html_document:
    fig_height: 4
    fig_width: 8
    highlight: kate
    theme: paper
  pdf_document: default
---

## Executive Summary

This report examines the decline of the thickness of Ozone layer over 90 years.

To find this, data was collected from 1927 to 2016 in Dobson units (yearly changes). Where a negative value in the dataset represents a decrease in Ozone thickness and a positive value represents an Ozone increase in the thickness.

#### Goals:

- [x] 

> Your task is to analyse the data by using the analysis methods covered in the first two modules of MATH1318 Time Series Analysis course in this semester. 

## R code 15%

```{r load-packages, message=TRUE, warning=TRUE}
# devtools::install_git('https://gitlab.com/botbotdotdotcom/packagr')
library(packagr)
packages <- c('AID','CombMSC','fGarch','forecast','FSAdata','fUnitRoots','lmtest','nortest','rugarch','TSA')
packagr(packages) # alpha package to check, install and load packages
```

```{r load-scripts, message=FALSE, warning=FALSE, include=FALSE}
setwd('./.')
source('./TSHandy.r') # check if updated

# sort score function
sort.score <- function(x, score = c("bic", "aic")){
  if (score == "aic"){
    x[with(x, order(AIC)),]
  } else if (score == "bic") {
    x[with(x, order(BIC)),]
  } else {
    warning('score = "x" only accepts valid arguments ("aic","bic")')
  }
}
```

```{r}
BoxCoxSearch = function(y, lambda=seq(-3,3,0.01), 
                        m= c("sf", "sw","ad" ,"cvm", "pt", "lt", "jb"), plotit = T, verbose = T){
  N = length(m)
  BC.y = array(NA,N)
  BC.lam = array(NA,N)
  for (i in 1:N){
    wrt <- switch(m[i], 
      'sf' = 'Shapiro-Francia Test',
      'sw' = 'Shapiro-Wilk  Test',
      'ad' = 'Anderson-Darling Test',
      'cvm' = 'Cramer-von Mises Test',
      'pt' = 'Pearson Chi-square Test',
      'lt' = 'Lilliefors Test',
      'jb' = 'Jarque-Bera Test'
    ) 
    print(paste0("------------- ",wrt," -------------"))
    out = tryCatch({boxcoxnc(y, method = m[i], lam = lambda, lambda2 = NULL, plot = plotit, alpha = 0.05, verbose = verbose)
      BC.lam[i] = as.numeric(out$lambda.hat)}, 
      error = function(e) print("No results for this test!"))
    
  }
  return(list(lambda = BC.lam,p.value = BC.y))
}
```

```{r}
residual.analysis <- function(model, std = TRUE,start = 2, class = c("ARIMA","GARCH","ARMA-GARCH")[1]){
  # If you have an output from arima() function use class = "ARIMA"
  # If you have an output from garch() function use class = "GARCH"
  # If you have an output from ugarchfit() function use class = "ARMA-GARCH"
  library(TSA)2
  library(FitAR)
  if (class == "ARIMA"){
    if (std == TRUE){
      res.model = rstandard(model)
    }else{
      res.model = residuals(model)
    }
  }else if (class == "GARCH"){
    res.model = model$residuals[start:model$n.used]
  }else if (class == "ARMA-GARCH"){
    res.model = model@fit$residuals
  }else {
    stop("The argument 'class' must be either 'ARIMA' or 'GARCH' ")
  }
  par(mfrow=c(3,2))
  plot(res.model,type='o',ylab='Standardised residuals', main="Time series plot of standardised residuals")
  abline(h=0)
  hist(res.model,main="Histogram of standardised residuals")
  acf(res.model,main="ACF of standardised residuals")
  pacf(res.model,main="PACF of standardised residuals")
  qqnorm(res.model,main="QQ plot of standardised residuals")
  qqline(res.model, col = 2)
  print(shapiro.test(res.model))
  k=0
  LBQPlot(res.model, lag.max = 30, StartLag = k + 1, k = 0, SquaredQ = FALSE)
}
```

```{r diff-functions}
default_ylab = 'TODO:'
default_xlab = 'Year'
fig_nums <- captioner()

doDiffAndPlot <- function(df.ts, diffCount, showPlot = T, showEacf=F) {
  ifelse(
    diffCount != 0, (df.ts = diff(df.ts, differences = diffCount)),
    'there is no diff\n')
  paste('diff: ', diffCount) %>% print()
  order = ar(diff(df.ts))$order
  paste('order count (k): ', order)
  diffAdfTest = adfTest(df.ts, lags = order, title = NULL, description = NULL)
  p <- diffAdfTest@test$p.value
  paste(
    'adf p-value:',
    p, (ifelse(p < 0.05, '< 0.05 significant', '> 0.05 insignificant')
    )) %>% print()
  if(showPlot) {
    par(mfrow = c(1,3))
    plot(
      df.ts, 
      type='o', 
      xlab=default_xlab, 
      # ylab=fig_nums(figureName, 
      #   paste('diff #', diffCount, ' of ', default_ylab, sep = '')
      # )
    )
    acf(df.ts)
    pacf(df.ts)
    par(mfrow=c(1,1))
  }
}
```

```{r}
startDate = '2013-04-27' #yyyy-mm-dd
endDate = '2019-02-24'

data <- read.csv("./Bitcoin_Historical_Price.csv", sep=",", fill=TRUE, col.names = FALSE)
data %>% class() # data.frame needs to be converted to time series

# remove commas from currency - credit to Zoe
data$FALSE. <- as.numeric(as.character(gsub(",","",data$FALSE.)))

inds <- seq(as.Date(startDate), as.Date(endDate), by = "day")
data.ts <- ts(
  data,
  start = c(2013, as.numeric(format(inds[1], "%j"))),
  frequency = 365.25) # or 365?
# Code source: https://stackoverflow.com/a/33129922
```

## Trend Models


```{r}
par(mfrow=c(1,1))
plot(data.ts,type='o',main="TODO: Time series plot of total number of dwelling units by private sector")

plot(data.ts,type='l',ylab='Sales')
# FIXME: points(y=data.ts,x=time(data.ts), pch=as.vector(season(data.ts)))
```

```{r}
par(mfrow=c(2,1))
acf(data.ts)
pacf(data.ts)
eacf(data.ts)
```

### linear trend model
```{r}
model1 = lm(data.ts~time(data.ts)) # label the linear trend model as model1
summary(model1)
```

```{r}
par(mfrow=c(1,1))
plot(data.ts,type='o',ylab='y')
abline(model1)
```


```{r}
residual.analysis(model1, std = TRUE,start = 1)
```


## Quadratic Model

```{r}
t = time(data.ts)
t2 = t^2
model2 = lm(data.ts~ t + t2) # label the quadratic trend model as model2
summary(model2)
par(mfrow=c(1,1))
plot(ts(fitted(model2)), ylim = c(min(c(fitted(model2), as.vector(data.ts))), max(c(fitted(model2),as.vector(data.ts)))),ylab='y',
     main = "Fitted quadratic curve.")
lines(as.vector(data.ts),type="o")
residual.analysis(model2, std = TRUE,start = 1)
```

TODO: this is monthly, we need daily
```{r}
month.=season(data.ts) # period added to improve table display and this line sets up indicators
model3=lm(data.ts~month.,-1) # -1 removes the intercept term
summary(model3)
par(mfrow=c(1,1))
plot(ts(fitted(model3)), ylim = c(min(c(fitted(model3), as.vector(data.ts))), max(c(fitted(model3),as.vector(data.ts)))),ylab='y',
     main = "Fitted quadratic curve.",type='p')
lines(as.vector(data.ts),type="o")

```{r}
residual.analysis(model3, std = TRUE,start = 1)
```

```{r}
sc.AIC = AIC(model1,model2,model3)
sort.score(sc.AIC, score = "aic")
```

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

This looks like model #2

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

#---- ARIMA MODELLING - Purchase Value ----

value <- read.csv("~/Desktop/MATH1318/Week12/purchaseValue.csv", col.names = FALSE)

value = ts(value,start=1976) #

par(mfrow=c(1,1))
plot(value,type='o',main="Time series plot of total purchase value")
# We observe trend, successive points. There is no seasonality and no certain sign of changeing variance.

par(mfrow=c(1,2))
acf(value)
pacf(value)

diff.value = diff(value,differences = 2)
par(mfrow=c(1,1))
plot(diff.value,type='o',ylab='Time series plot of the first difference of total purchase value')


ar(diff(diff.value))
adfTest(diff.value, lags = 4,  title = NULL,description = NULL)

# After detrending the sereis we observe, volatility clustering!

bc.search = BoxCoxSearch(y=value, lam=seq(-3,3,0.01), m= c("sf", "sw","ad" ,"cvm", "pt", "lt", "jb","ac"), plotit = T, verbose = T)

lambda = 0.17
BC.value = ((value^lambda)-1)/lambda

ar(diff(BC.value))
adfTest(BC.value, lags = 0,  title = NULL,description = NULL)

diff.value.BC = diff(BC.value,differences = 1)
ar(diff(diff.value.BC))
adfTest(diff.value.BC, lags = 3,  title = NULL,description = NULL)


par(mfrow=c(1,1))
plot(diff.value.BC,type='o',ylab='Time series plot of the first difference of total purchase value')

par(mfrow=c(1,2))
acf(diff.value.BC)
pacf(diff.value.BC)
# Time series plot, ACF and PACF do not show a clear trend. So I'll go on with the first difference.

eacf(diff.value.BC,ar.max = 5, ma.max = 5)
#{ARIMA(0,1,1), ARIMA(1,1,1)}

par(mfrow=c(1,1))
res = armasubsets(y=diff.value.BC,nar=5,nma=5,y.name='test',ar.method='ols')
plot(res)


# ARIMA(0,1,1)
model_011_css = arima(BC.value,order=c(0,1,1),method='CSS')
coeftest(model_011_css)

model_011_ml = arima(BC.value,order=c(0,1,1),method='ML')
coeftest(model_011_ml)

# ARIMA(1,1,1)
model_111_css = arima(BC.value,order=c(1,1,1),method='CSS')
coeftest(model_111_css)

model_111_ml = arima(BC.value,order=c(1,1,1),method='ML')
coeftest(model_111_ml)

residual.analysis(model_111_ml, std = TRUE,start = 1)

# What if we go on with the second difference

diff.value= diff(value,differences = 2)
ar(diff(diff.value))
adfTest(diff.value, lags = 4,  title = NULL,description = NULL)

par(mfrow=c(1,1))
plot(diff.value,type='o',ylab='Time series plot of the first difference of total purchase value')

par(mfrow=c(1,2))
acf(diff.value)
pacf(diff.value)
eacf(diff.value,ar.max = 5, ma.max = 5)

# ARIMA(1,2,0); ARIMA(1,2,1); ARIMA(2,2,1)

modelList <- list(c(1,2,0), c(1,2,1), c(2,2,1))
modelEstimation <- myCandidate(value, orderList = modelList, methodType = "ML")


modelEstimation$significanceTest

modelEstimation$IC

residual.analysis(modelEstimation$model[[1]], std = TRUE,start = 1)
residual.analysis(modelEstimation$model[[2]], std = TRUE,start = 1)
residual.analysis(modelEstimation$model[[3]], std = TRUE,start = 1)


abs.diff.value = abs(diff.value)
sqr.diff.value = diff.value^2

par(mfrow=c(1,2))
acf(abs.diff.value)
pacf(abs.diff.value)
eacf(abs.diff.value,ar.max = 5, ma.max = 5)
#{ARMA(1,2), ARMA(2,2)} ==> {GARCH(1,1), GARCH(2,2)}

par(mfrow=c(1,2))
acf(sqr.diff.value)
pacf(sqr.diff.value)
eacf(sqr.diff.value,ar.max = 5, ma.max = 5)
#{ARMA(2,1), ARMA(2,0)} ==> {GARCH(2,2)}


model2<-ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1, 1)), 
                   mean.model = list(armaOrder = c(1, 0), include.mean = FALSE), 
                   distribution.model = "norm")
m.2<-ugarchfit(spec=model2,data=diff.value)
# It is not possbile to apply GARCH models with a small dataset 

model_120_ml = arima(diff.value, order=c(1,0,0),method='ML')
res.m.120 = residuals(model_120_ml)

m.11 = garch(res.m.120,order=c(1,1),trace = FALSE)
m.11_2 = garchFit(formula = ~garch(1,1), data =res.m.120, algorithm = "lbfgsb" )
summary(m.11_2)
res = m.11_2@residuals
acf(res)
pacf(res)
par(mfrow=c(1,1))
plot(m.11_2@residuals)

#---- SARIMA MODELLING ---

jobs <- read.csv("~/Desktop/MATH1318/Week12//numberJobs.csv", col.names = FALSE)

jobs = ts(jobs,start=c(1980,1),end=c(2016,2),frequency = 4)

par(mfrow=c(1,1))
plot(jobs,type='o',main="Time series plot of the number jobs advertised")
par(mfrow=c(1,2))
acf(jobs)
pacf(jobs)
eacf(jobs)

m1.jobs = arima(jobs,order=c(0,0,0),seasonal=list(order=c(0,1,0), period=4))
res.m1 = residuals(m1.jobs);  
par(mfrow=c(1,1))
plot(res.m1,xlab='Time',ylab='Residuals',main="Time series plot of the residuals")
par(mfrow=c(1,2))
acf(res.m1, lag.max = 36, main = "The sample ACF of the residuals")
pacf(res.m1, lag.max = 36, main = "The sample PACF of the residuals")


m2.jobs = arima(jobs,order=c(0,1,0),seasonal=list(order=c(0,1,0), period=4))
res.m2 = residuals(m2.jobs);  
par(mfrow=c(1,1))
plot(res.m2,xlab='Time',ylab='Residuals',main="Time series plot of the residuals")
par(mfrow=c(1,2))
acf(res.m2, lag.max = 36, main = "The sample ACF of the residuals")
pacf(res.m2, lag.max = 36, main = "The sample PACF of the residuals")
#Significant seasonal lags

m3.jobs = arima(jobs,order=c(0,1,0),seasonal=list(order=c(2,1,1), period=4))
res.m3 = residuals(m3.jobs);  
par(mfrow=c(1,1))
plot(res.m3,xlab='Time',ylab='Residuals',main="Time series plot of the residuals")
par(mfrow=c(1,2))
acf(res.m3, lag.max = 36, main = "The sample ACF of the residuals")
pacf(res.m3, lag.max = 36, main = "The sample PACF of the residuals")

eacf(res.m3)
# SARIMA(1,1,1)x(2,1,1)_4; SARIMA(1,1,2)x(2,1,1)_4; SARIMA(2,1,2)x(2,1,1)_4

m4.jobs = arima(jobs,order=c(1,1,1),seasonal=list(order=c(2,1,1), period=4))
res.m4 = residuals(m4.jobs);  
par(mfrow=c(1,1))
plot(res.m4,xlab='Time',ylab='Residuals',main="Time series plot of the residuals")
par(mfrow=c(1,2))
acf(res.m4, lag.max = 36, main = "The sample ACF of the residuals")
pacf(res.m4, lag.max = 36, main = "The sample PACF of the residuals")

m5.jobs = arima(jobs,order=c(2,1,1),seasonal=list(order=c(2,1,1), period=4))
coeftest(m5.jobs )
res.m5 = residuals(m5.jobs);  
par(mfrow=c(1,1))
plot(res.m5,xlab='Time',ylab='Residuals',main="Time series plot of the residuals")
par(mfrow=c(1,2))
acf(res.m5, lag.max = 36, main = "The sample ACF of the residuals")
pacf(res.m5, lag.max = 36, main = "The sample PACF of the residuals")

m6.jobs = arima(jobs,order=c(2,1,2),seasonal=list(order=c(2,1,1), period=4))
coeftest(m6.jobs )
res.m6 = residuals(m6.jobs);  
par(mfrow=c(1,1))
plot(res.m6,xlab='Time',ylab='Residuals',main="Time series plot of the residuals")
par(mfrow=c(1,2))
acf(res.m6, lag.max = 36, main = "The sample ACF of the residuals")
pacf(res.m6, lag.max = 36, main = "The sample PACF of the residuals")

coeftest(m4.jobs)
coeftest(m5.jobs)
coeftest(m6.jobs)

residual.analysis(m6.jobs, std = TRUE,start = 1)

sc.AIC = AIC(m4.jobs,m5.jobs,m6.jobs)
sort.score(sc.AIC, score = "aic")

m6.jobs_2 = Arima(jobs,order=c(2,1,2),seasonal=list(order=c(2,1,1), period=4))
future = forecast(m6.jobs_2, h = 24)
par(mfrow=c(1,1))
plot(future)


# --- GARCH MODELS ---

rate <- read.csv("~/Desktop/MATH1318/Week12//exchangeRate.csv", col.names = FALSE)

rate = ts(rate) 

return = diff(log(rate))*100
par(mfrow=c(1,1))
plot(return,type='o',ylab="Exchange rate AUD/USD",main="Time series plot of exchange rate AUD/USD")
acf(return)
pacf(return)
eacf(return)
# ACF, PACF and EACF all shows pattern of white noise for the correlation structure. However, there is an ARCH effect present in the series.
par(mfrow=c(1,1))
McLeod.Li.test(y=return,main="McLeod-Li Test Statistics for return series")
# McLeod-Li test is significnat at 5% level of significance for most of the lags. This gives a strong idea about existence of volatiliy clustering.
qqnorm(return,main="Q-Q Normal Plot of seismic Lg wave series")
qqline(return) # Relatively fat tails is in accordance with volatiliy clustering

#So we'll use absolute value and square transformations to figure out this ARCH effect.
abs.return = abs(return)
sq.return = return^2

par(mfrow=c(1,2))
acf(abs.return, ci.type="ma",main="The sample ACF plot for absolute return series")
pacf(abs.return, main="The sample PACF plot for absolute return series")
eacf(abs.return)
# After the absolute value transformation, we observe many signficicant lags in both ACF and PACF. Also, EACF does not suggest an ARMA(0,0) model.
# From the EACF, we can identify ARMA(1,1) and ARMA(1,2) models for absolute value series. 
# These models correspond to parameter settings of [max(1,1),1] and [max(1,2),1]. So the corresponding 
# tentative GARCH models are GARCH(1,1) and GARCH(2,1).

par(mfrow=c(1,2))
acf(sq.return, ci.type="ma",main="The sample ACF plot for squared return series")
pacf(sq.return, main="The sample PACF plot for squared return series")
eacf(sq.return)
# After the square transformation, we boserve many signficicant lags in both ACF and PACF. Also, EACF does not suggest an ARMA(0,0) model.
# From the EACF, we can identify ARMA(1,1) and ARMA(1,2) models for squared series. 
# These models correspond to parameter settings of [max(1,1),1] and [max(1,2),1]. So the corresponding 
# tentative GARCH models are GARCH(1,1) and GARCH(2,1).


model1<-ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1, 1)), 
                  mean.model = list(armaOrder = c(0, 0), include.mean = FALSE), 
                  distribution.model = "norm")
m.11<-ugarchfit(spec=model1,data=return, out.sample = 100)
plot(m.11)


model2<-ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(2, 1)), 
                   mean.model = list(armaOrder = c(0, 0), include.mean = FALSE), 
                   distribution.model = "norm")
m.21<-ugarchfit(spec=model2,data=return, out.sample = 100)
plot(m.21)


forc = ugarchforecast(m.11, data = return, n.ahead = 10, n.roll =10)
plot(forc, which ="all")
```
